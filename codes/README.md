# 问题

>   codes -> code
>
>   没有显示print
>
>   train_histogram
>
>   section：data_type
>
>   用时？
>
>   stringvec

### 说明文档

+ 请确保对测试集的预测结果可以由提交的代码产出，预测流程所使用到的源码都要包含在提交的文件中。

+ 所使用的依赖（操作系统版本，MATLAB/Python的版本，需要安装的Python package，使用到的TensorFlow，PyTorch，MXNet的版本等）都需要在README文件中写明。

+ 如果使用到GPU，请在README中注明CUDA版本、CUDNN版本等。

+ 如果使用深度神经网络，请提供网络定义等内容，确保能够产出预测结果。

+ 如果有需要编译的文件，请提供编译的脚本。

+ 请提供main.py文件作为程序入口，确保可以通过执行该文件来运行预测程序，得到最终结果，并将结果保存到上述的data/prediction_result/result.csv文件中。读入文件的路径请使用相对路径，比如 ../data/XX 

+ 代码要求能够复现提交成绩最好一次的结果，且不能使用与样本ID相关的信息参与建模和预测，不能有对个别样本输出结果的特别处理。


# 解决方案及算法介绍

## 赛题简介

近年来，各种勒索软件、木马、病毒、恶意挖矿程序等多种形式恶意软件不断涌现，恶意软件作者为逃避检测，在恶意软件组件中引入了多态性。虽然属于同一恶意软件“家族”的恶意文件具有相同形式的恶意行为，但由于编写者使用了各种策略不断修改和/或混淆，原本隶属同一家族的文件看起来像许多不同的文件，给检测识别的准确性带来了高度挑战。本赛题的任务是要我们通过分析给定的训练集中10个家族的恶意软件的特点，设计算法并构建AI模型，来对测试集中各个家族的恶意软件进行区分。

### 一、解题方案思路（作品特色亮点）-->问卷（待扩展）

本文档描述了我们团队针对2021CCF BDCI数字安全公开赛“基于人工智能的恶意软件家族分类”这一赛题的解决方案及算法。我们的方案基于针对多个不同维度特征的特征工程（包括特征提取、特征融合和特征选择等）、样本均衡、梯度增强（XGBoost）和模型集成等人工智能策略。该方案最终取得了0.149394的多分类对数损失，在线上测试集排行榜中排名第二。

**特征工程**：提取了PE文件的字节直方图、字节熵直方图、字符串信息特征。由于PE头被截取，我们通过在汇编文件中提取了节区、导入表和导出表信息。

**模型构建**：

**==总体流程图==**:



## 二、特征工程

### 2.1 单特征提取

我们提取的单特征可以分为三种类型：Ember 、TF-IDF 、Asm2Vec 。所有特征提取的脚本均在`features.py`中实现，所有特征工程的脚本均在`feature_engineering.py`中实现。

#### 2.1.1 Ember 特征

PE文件样本去除了所有头部信息，因此在开源的Ember静态特征提取方法中可以使用不需要头部字段的**字节直方图** `ByteHistogram()`,**字节熵直方图** `ByteEntropyHistogram()` ,**字符串信息特征** `StringExtractor()`。

+   **字节直方图**：统计文件中0-255共计256个字节整数值的出现个数
+   **字节熵直方图**：近似文件熵与字节值的联合概率分布
    -   滑动一个2048字节的窗口，步长为1024字节
    -   计算每个2048字节窗口的熵
    -   统计滑动窗口的（字节，熵值）对，最后转换成1x256维的特征向量
+   **字符串信息特征**：关于可打印字符串（0x20-0x7f，至少包含5个字符）的统计信息
    -   字符串的数量、平均长度
    -   字符串中字符的直方图和熵直方图
    -   是否以具有特殊含义的字符串开头
        -   `C:\` - 路径
        -   `http://或https://` - URL
        -   `HKEY_` - 注册表项
        -   `MZ` - 捆绑文件

>https://github.com/elastic/ember
>
>https://arxiv.org/pdf/1508.03096.pdf

由于PE文件中缺失了很多头部信息，所以我们选择了在汇编文件中提取来弥补。我们通过在汇编文件中提取了**节区特征** `SectionInfo()`、**导入表特征** `ImportsInfo()`和**导出表特征** `ExportsInfo()`。

-   **节区特征**
    -   节区的统计特征：节区（section）个数、段（segment）个数、异常节区个数（节区名为空、大小为0）、可读可执行和可写的节区个数、是否存在调试段、重定位段、资源段或TLS段
    -   节区大小：节区进行对齐处理前节的大小和实际在磁盘中所占的空间大小
    -   入口节区信息：第一个可执行节区的节区名和相关属性
-   **导入表特征**
    -   导入地址表中记录的动态链接库以及从各个动态链接库中导入的函数列表
-   **导出表特征**
    -   导出函数的列表

#### 2.1.2 TF-IDF 特征

我们提取了**可读性字符串**和**操作码序列**做**词频-逆文件频率（TF-IDF）**，一个词或一段汇编代码在一个样本中出现次数越多, 同时在所有样本中出现次数越少, 越能够代表该样本。但是由于本赛题是10分类问题，而且样本极度不平衡，所以我们将**样本数量锐减的家族（7，8，9）训练家样本不添加进词汇库。**

##### （1）可读性字符串 ` StringExtractor.tfidf_features()`

我们在PE文件中提取了正则`re.compile(b"[a-zA-Z]+")`匹配字符串，并对**长于20的字符串进行拆分**并保存了带有**元音**的字符串。

**TF-IDF参数1**：`{'max_features':1000}` ,单特征使用

**TF-IDF参数2**：`{'max_features':300}`，特征融合

**举例：**

```python
['tmEVPuuuW', 'uGEjDP', 'PEPVVVVVVPV', 'ExitProcess']
```

##### （2）操作码序列 `OpcodeInfo.tfidf_features()`

我们在汇编文件`'Segment type:  Pure code'`段中带有操作码的行中提取了**操作码、第一个操作数的寄存器名称和汇编文件的注释内容**。并且如果操作数为`call`,我们提取了不为`sub_, dword_, unkown_`开头的函数名。并在每个函数或者主程序之前添加`;`符号做分词。

**TF-IDF参数**：`{'stop_words' : [';'], 'ngram_range' : (1, 3), 'max_features':1000}`

**举例：**

```assembly
		push	ebp
		mov	ebp, esp
		mov	eax, 5170h
		call	__alloca_probe
		cmp	[ebp+arg_8], 0
loc_40102C:				; CODE XREF: sub_401000+23j
		mov	edx, [ebp+arg_0]
		test	edx, edx
```

**提取后：**

```json
['pushebp','movsbp','moveax','call__alloca_probe',';','cmpebp','movedx','testedx']
```

#### 2.1.3 Asm2Vec 特征



#### 2.1.4 **==每个单特征预测结果图==**

### 2.2 特征选择

对使用了TF-IDF的特征进行了类权重`ExtraTreesClassifier`特征选择

```python
classes_weights = class_weight.compute_sample_weight(
        class_weight='balanced',
        y=train_labels
)
selector=SelectFromModel(estimator=ExtraTreesClassifier(n_estimators=200)).fit(train_data, train_labels, sample_weight=classes_weights)
```

### 2.3 特征融合

**==特征融合预测结果图==**

## 三、模型构建

### 3.1 加权软投票



**==各个数据集权重图==**

**==加权投票的变化==**

### 3.2 多模型集成

>   ##### 样本均衡
>
>   数据集中存在的一些难点：
>   训练集中样本不平衡；训练集与测试集各家族样本比例不一致

## 四、代码结构

```
|-- code
    |-- __init__.py
    |-- features.py
    |-- feature_engineering.py
    |-- model.py
    |-- train.py
    |-- predict.py
    |-- main.py
    |-- README.md # 解决方案及算法介绍
```

## 五、建模算力与环境说明

## 六、参考文献

