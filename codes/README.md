# 问题

>   codes -> code
>
>   没有显示print
>
>   train_histogram
>
>   section：data_type
>
>   用时？
>
>   stringvec

### 说明文档

+ 请确保对测试集的预测结果可以由提交的代码产出，预测流程所使用到的源码都要包含在提交的文件中。

+ 所使用的依赖（操作系统版本，MATLAB/Python的版本，需要安装的Python package，使用到的TensorFlow，PyTorch，MXNet的版本等）都需要在README文件中写明。

+ 如果使用到GPU，请在README中注明CUDA版本、CUDNN版本等。

+ 如果使用深度神经网络，请提供网络定义等内容，确保能够产出预测结果。

+ 如果有需要编译的文件，请提供编译的脚本。

+ 请提供main.py文件作为程序入口，确保可以通过执行该文件来运行预测程序，得到最终结果，并将结果保存到上述的data/prediction_result/result.csv文件中。读入文件的路径请使用相对路径，比如 ../data/XX 

+ 代码要求能够复现提交成绩最好一次的结果，且不能使用与样本ID相关的信息参与建模和预测，不能有对个别样本输出结果的特别处理。


# 解决方案及算法介绍

## 赛题简介

近年来，各种勒索软件、木马、病毒、恶意挖矿程序等多种形式恶意软件不断涌现，恶意软件作者为逃避检测，在恶意软件组件中引入了多态性。虽然属于同一恶意软件“家族”的恶意文件具有相同形式的恶意行为，但由于编写者使用了各种策略不断修改和/或混淆，原本隶属同一家族的文件看起来像许多不同的文件，给检测识别的准确性带来了高度挑战。本赛题的任务是要我们通过分析给定的训练集中10个家族的恶意软件的特点，设计算法并构建AI模型，来对测试集中各个家族的恶意软件进行区分。

### 一、解题方案思路（作品特色亮点）-->问卷（待扩展）

本文档描述了我们团队针对2021CCF BDCI数字安全公开赛“基于人工智能的恶意软件家族分类”这一赛题的解决方案及算法。我们的方案基于针对多个不同维度特征的特征工程（包括特征提取、特征融合和特征选择等）、样本均衡、梯度增强（XGBoost）和模型集成等人工智能策略。该方案最终取得了0.149394的多分类对数损失，在线上测试集排行榜中排名第二。

**特征工程**：提取了PE文件的字节直方图、字节熵直方图、字符串信息特征。由于PE头被截取，我们通过在汇编文件中提取了节区、导入表和导出表信息。

**模型构建**：

**==总体流程图==**:



### 二、特征工程

#### 2.1 单特征提取

我们提取的单特征可以分为三种类型：Ember 、TF-IDF 、Asm2Vec 。所有特征提取的脚本均在`features.py`中实现，所有特征工程的脚本均在`feature_engineering.py`中实现。

>   1) 二进制字节流特征。
>
>   2) 类字符串特征。
>
>   3) 文件格式解析特征。

##### 2.1.1 Ember 特征

PE文件样本去除了所有头部信息，因此在开源的Ember静态特征提取方法中可以使用不需要头部字段的**字节直方图** `ByteHistogram()`,**字节熵直方图** `ByteEntropyHistogram()` ,**字符串信息特征** `StringExtractor()`。

+   ==字节直方图==
+   ==字节熵直方图== 
+   ==字符串信息特征==

**==以上简单介绍原理和特征内容==**

>https://github.com/elastic/ember
>
>https://arxiv.org/pdf/1508.03096.pdf

由于PE文件中缺失了很多头部信息，所以我们选择了在汇编文件中提取来弥补。我们通过在汇编文件中提取了**节区特征** `SectionInfo()`、**导入表特征** `ImportsInfo()`和**导出表特征** `ExportsInfo()`。

+   **==节区特征==**

+   ==**导入表特征**==
+   ==**导出表特征**==

**==以上简单介绍原理和特征内容==**

##### 2.1.2 TF-IDF 特征



+   可读性字符串
+   操作码

我们提取了`'Segment type:  Pure code'`段中带有操作码的行，提取了操作码、第一个操作数的寄存器名称和汇编文件的注释内容。并且如果操作数为`call`,我们提取了不为`sub_,dword_,unkown`开头的函数名。并在每个函数或者主程序之前添加`;`符号做分词。

**举例：**

```
		push	ebp
		mov	ebp, esp
		mov	eax, 5170h
		call	__alloca_probe
		cmp	[ebp+arg_8], 0
		
loc_40102C:				; CODE XREF: sub_401000+23j
		mov	edx, [ebp+arg_0]
		test	edx, edx
```

**提取后：**

```
['pushebp','movsbp','moveax','call__alloca_probe',';','movedx','testedx']
```



下采样样

##### 2.1.3 Asm2Vec 特征



##### 2.1.4 **==每个单特征预测结果图==**

#### 2.2 特征选择

对使用了TF-IDF的特征进行了类权重`ExtraTreesClassifier`特征选择

```python
classes_weights = class_weight.compute_sample_weight(
        class_weight='balanced',
        y=train_labels
)
selector=SelectFromModel(estimator=ExtraTreesClassifier(n_estimators=200)).fit(train_data, train_labels, sample_weight=classes_weights)
```

#### 2.3 特征融合

**==特征融合预测结果图==**

### 三、模型构建

#### 3.1 加权软投票



**==各个数据集权重图==**

**==加权投票的变化==**

#### 3.2 多模型集成

>   ##### 样本均衡
>
>   数据集中存在的一些难点：
>   训练集中样本不平衡；训练集与测试集各家族样本比例不一致

### 四、代码结构

```
|-- code
    |-- __init__.py
    |-- features.py
    |-- feature_engineering.py
    |-- model.py
    |-- train.py
    |-- predict.py
    |-- main.py
    |-- README.md # 解决方案及算法介绍
```

### 五、建模算力与环境说明

### 六、参考文献

